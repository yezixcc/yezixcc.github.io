<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构," />










<meta name="description" content="树形结构是一种非线性的数据结构，它由节点（node）和边（edge）组成。每个节点可以有零个或多个子节点，而除了根节点（root）外，每个节点都有且只有一个父节点。 树形结构常用来表示具有层次关系的数据。">
<meta property="og:type" content="article">
<meta property="og:title" content="树形结构">
<meta property="og:url" content="http://yoursite.com/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Sivan的博客">
<meta property="og:description" content="树形结构是一种非线性的数据结构，它由节点（node）和边（edge）组成。每个节点可以有零个或多个子节点，而除了根节点（root）外，每个节点都有且只有一个父节点。 树形结构常用来表示具有层次关系的数据。">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20200828200834146.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20200828201659327.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20200828202015044.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20200828202922019.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20200828203120019.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201117195500464.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201117204738098.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201118181003027.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201118192011155.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201118193307242.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201119195446566.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201126165558039.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201126171610410.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201126174517611.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20201126175549541.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9dd2eab0c7f04a2fbd74949ae6e24b3b.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webp-20230516144029974.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/600b0f13-9051-4410-94eb-a9cb830517f2.jpg">
<meta property="og:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/c057f73c-254f-4a34-ba1e-b8a78f1bbcce.jpg">
<meta property="article:published_time" content="2020-06-18T14:46:03.000Z">
<meta property="article:modified_time" content="2023-08-30T02:56:25.892Z">
<meta property="article:author" content="Sivan">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20200828200834146.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/18/数据结构/树形结构/"/>





  <title>树形结构 | Sivan的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sivan的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">随遇而安</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sivan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sivan的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">树形结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-18T22:46:03+08:00">
                2020-06-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>树形结构是一种非线性的数据结构，它由节点（node）和边（edge）组成。每个节点可以有零个或多个子节点，而除了根节点（root）外，每个节点都有且只有一个父节点。</p>
<p>树形结构常用来表示具有层次关系的数据。</p>
<a id="more"></a>

<!-- toc -->

<ul>
<li><a href="#一-基本概念">一、基本概念</a><ul>
<li><a href="#1-节点">1、节点</a></li>
<li><a href="#2-子树">2、子树</a></li>
<li><a href="#3-节点的度">3、节点的度</a></li>
<li><a href="#4-树的度">4、树的度</a></li>
<li><a href="#6-层数">6、层数</a></li>
<li><a href="#6-节点的深度">6、节点的深度</a></li>
<li><a href="#8-节点的高度">8、节点的高度</a></li>
<li><a href="#8-树的高度和深度">8、树的高度和深度</a></li>
<li><a href="#9-直径">9、直径</a></li>
<li><a href="#10-有序树-无序树-森林">10、有序树、无序树、森林</a></li>
</ul>
</li>
<li><a href="#二-二叉树">二、二叉树</a><ul>
<li><a href="#1-真二叉树">1、真二叉树</a></li>
<li><a href="#2-满二叉树">2、满二叉树</a></li>
<li><a href="#3-完全二叉树">3、完全二叉树</a></li>
<li><a href="#4-二叉搜索树">4、二叉搜索树</a><ul>
<li><a href="#1-二叉树遍历">1、二叉树遍历</a><ul>
<li><a href="#1-前序遍历">1、前序遍历</a></li>
<li><a href="#2-中序遍历">2、中序遍历</a></li>
<li><a href="#3-后序遍历">3、后序遍历</a></li>
<li><a href="#4-层序遍历">4、层序遍历</a></li>
<li><a href="#5-接口设计">5、接口设计</a></li>
</ul>
</li>
<li><a href="#2-avl树">2、AVL树</a></li>
<li><a href="#3-红黑树">3、红黑树</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#三-b树">三、B树</a></li>
<li><a href="#四-trie树">四、Trie树</a></li>
<li><a href="#五-哈夫曼树">五、哈夫曼树</a></li>
<li><a href="#六-集合treeset">六、集合(TreeSet)</a></li>
<li><a href="#七-映射treemap">七、映射(TreeMap)</a></li>
</ul>
<!-- tocstop -->

<h3><span id="一-基本概念">一、基本概念</span></h3><p>文件夹，组织架构都是树形结构，这种结构大大提高了搜索效率。</p>
<img src="/images/数据结构/image-20200828200834146.png" alt="image-20200828200834146" style="zoom:50%;">

<h5><span id="1-节点">1、节点</span></h5><p>每一个点都是节点：</p>
<ol>
<li><strong>根节点</strong>：1是根节点；</li>
<li><strong>父节点</strong>：节点上面的节点是它父节点，比如2的父节点是1；</li>
<li><strong>子节点</strong>：节点下面的节点是它的子节点，比如2是1的子节点；</li>
<li><strong>兄弟节点</strong>：同一个节点下的字节点成为兄弟节点，比如2，3，4，5，6是兄弟节点，但21和31不是兄弟节点。</li>
<li><strong>叶子节点</strong>：没有子树（度为0）的节点。比如节点61，4。</li>
</ol>
<ul>
<li>一颗树可以没有任何节点，称为<strong>空树</strong>;</li>
<li>一棵树可以只有1个节点，就是根节点；</li>
</ul>
<h5><span id="2-子树">2、子树</span></h5><p><strong>左子树、右子树。</strong></p>
<img src="/images/数据结构/image-20200828201659327.png" alt="image-20200828201659327" style="zoom:50%;">

<p>1，2，3，4，5都是单独的一棵树，他们都是1的子树。</p>
<img src="/images/数据结构/image-20200828202015044.png" alt="image-20200828202015044" style="zoom:50%;">

<p>左边的就是左子树，右边的就是右子树。比如1就是2的左子树，2就是2的右子树。</p>
<h5><span id="3-节点的度">3、节点的度</span></h5><p>就是子树的个数。比如2的子树只有21，22，所以它的度就是2，节点61没有子树，所以度是0。</p>
<h5><span id="4-树的度">4、树的度</span></h5><p>所有节点度中的最大值。比如节点1的度是5，是最大的度，那么树的度就是5。</p>
<h5><span id="6-层数">6、层数</span></h5><p>根节点在第1层，根节点的子节点在第2层，以此类推。</p>
<img src="/images/数据结构/image-20200828202922019.png" alt="image-20200828202922019" style="zoom:50%;">

<h5><span id="6-节点的深度">6、节点的深度</span></h5><p>从根节点到当前节点的唯一路径上的节点总数。比如节点223的就经过了1，2，22，223。所以节点223的深度是4。</p>
<img src="/images/数据结构/image-20200828203120019.png" alt="image-20200828203120019" style="zoom:50%;">

<h5><span id="8-节点的高度">8、节点的高度</span></h5><p>从当前节点到最远叶子节点的路径上的节点总数。如下2节点的深度就是2，高度是3。</p>
<img src="/images/数据结构/image-20201117195500464.png" alt="image-20201117195500464" style="zoom:50%;">

<h5><span id="8-树的高度和深度">8、树的高度和深度</span></h5><p>所有节点高度中的最大值，所有节点深度中的最大值。树的深度等于树的高度。上面的树的高度4，深度4。</p>
<h5><span id="9-直径">9、直径</span></h5><p>二叉树中任意两个节点之间最长路径节点数减1（边数）。</p>
<h5><span id="10-有序树-无序树-森林">10、有序树、无序树、森林</span></h5><ul>
<li>有序树：树中任意节点的子节点之间有顺序关系，如果子节点间调换了顺序就称为了不同的树；</li>
<li>无序树：树中任意节点的子节点之间没有顺序关系，也称自由树；</li>
<li>森林：由m（m&gt;=0）棵互不相交的树组成的集合。</li>
</ul>
<h3><span id="二-二叉树">二、二叉树</span></h3><img src="/images/数据结构/image-20201117204738098.png" alt="image-20201117204738098" style="zoom:50%;">

<ul>
<li><p>每个节点的度最大为2（即最多拥有2棵子树）；</p>
</li>
<li><p>左子树和右子树是有顺序的；</p>
</li>
<li><p>即使某节点只有一棵子树，也要区分左右子树；</p>
</li>
<li><p><strong>非空二叉树的第i层，最多有2^(i-1)个节点（i&gt;=1）;</strong></p>
</li>
<li><p><strong>高度为h的二叉树最多有2^h-1个节点（h&gt;=1）;</strong></p>
</li>
<li><p><strong>对于任何一棵非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则有n0 = n2 + 1;</strong></p>
</li>
</ul>
<h4><span id="1-真二叉树">1、真二叉树</span></h4><ul>
<li>所有节点的度要么是0，要么是2。</li>
</ul>
<p>图1 就是真二叉树，图2 就不是真二叉树。</p>
<img src="/images/数据结构/image-20201118181003027.png" alt="image-20201118181003027" style="zoom:50%;">



<h4><span id="2-满二叉树">2、满二叉树</span></h4><ul>
<li>所有节点的度要么为0，要么为2；</li>
<li>所有的叶子节点在最后一层；</li>
<li>每一层上的节点数都是前一层的节点数的2倍。</li>
</ul>
<p>所有满二叉树一定是真二叉树，真二叉树不一定是满二叉树。在同样高度的二叉树中，满二叉树的叶子节点数最多，总节点数最多。</p>
<img src="/images/数据结构/image-20201118192011155.png" alt="image-20201118192011155" style="zoom:50%;">

<p>假设满二叉树的高度为h(h &gt;= 1)，那么：</p>
<ul>
<li>第i层节点数量：2^(i-1)；</li>
<li>叶子节点数量：2^(h-1)；</li>
<li>总节点数量n = 2^h - 1 = 2^0+2^1+2^2+…+2^(h-1)，h = log2(n+1)；</li>
</ul>
<h4><span id="3-完全二叉树">3、完全二叉树</span></h4><p>叶子节点只会出现在最后2层，且最后1层的叶子节点都靠左对齐。其实就是节点从上往下，从左到右排布，如果排满了就成了满二叉树，没有排满就是完全二叉树。</p>
<img src="/images/数据结构/image-20201118193307242.png" alt="image-20201118193307242" style="zoom:50%;">

<ul>
<li>完全二叉树从根结点到倒数第二层是一棵满二叉树；</li>
<li>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树；</li>
<li>度为1的节点只有左子树；</li>
<li>度为1的节点要么是1个，要么是0个；</li>
<li>同样节点数量的二叉树，完全二叉树的高度最小；</li>
<li>假设完全二叉树的高度为h(h&gt;=1)，那么：<ul>
<li>至少有2^(h-1)个节点（2^0+2^1+…+2^(h-2)+1）;</li>
<li>最多有2^h-1个节点（2^0+2^1+…+2^(h-1)）;</li>
<li>总节点数n，h = floor(log2n) + 1；</li>
</ul>
</li>
</ul>
<p>假设叶子节点数是n0，度为1的节点数n1，度为2的节点数n2，总节点个数 n = n0 + n1 + n2，而且 上面推导出了公式n0 = n2 + 1 , 所以 n = 2n0 + n1 - 1。完全二叉树n1要么是1，要么是0：</p>
<ul>
<li>当n1 = 1时，n = 2n0， n必然是偶数，所以叶子节点个数 <strong>n0 = n / 2</strong>；</li>
<li>当n1 = 0时，n = 2n0 - 1， n必然是奇数，所以叶子节点个数 <strong>n0 = (n + 1) / 2</strong>；</li>
</ul>
<p>而对于代码而言，/ 都是向下取整的，所以编程的时候直接使用 n0 = (n + 1) / 2 或者 n0 = (n + 1) &gt;&gt; 1（右移1位就等价于除以2）就好了，不用判断n为奇数还是偶数。</p>
<p>如果将所有非叶节点按从上到下、从左到右的顺序编号，则编号为i的节点的左子节点编号为2i，右子节点编号为2i+1。左子树都为偶数，右子树都为奇数。（<strong>下标从1开始</strong>）</p>
<p>常用于堆排序。</p>
<h4><span id="4-二叉搜索树">4、二叉搜索树</span></h4><p>二叉树的一种，又称二叉查找树，二叉排序树。二叉搜索树可以大大提高搜索数据的效率。</p>
<img src="/images/数据结构/image-20201119195446566.png" alt="image-20201119195446566" style="zoom:50%;">

<ul>
<li>左子树节点值都小于其根节点的值，右子树节点值都大于其根节点值；</li>
<li>对于任意节点，其左右子树都是二叉搜索树；</li>
<li>存储的元素必须具备可比较性，元素不能为空；</li>
<li>元素没有索引的概念；</li>
</ul>
<p><strong>中序遍历</strong>可以得到一个有序的节点序列；</p>
<p>搜索、插入和删除某个元素的时间复杂度均为O(logn)。</p>
<ol>
<li><p>节点类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E element;  <span class="comment">/// 节点值</span></span><br><span class="line">    Node&lt;E&gt; left;   <span class="comment">/// 左子节点</span></span><br><span class="line">    Node&lt;E&gt; right;  <span class="comment">/// 右子节点</span></span><br><span class="line">    Node&lt;E&gt; parent; <span class="comment">/// 父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子节点可以不存在，所以不写在构造函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>..parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    elementNotNullCheck(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的是第一个节点 -- 根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node&lt;&gt;(element, <span class="keyword">null</span>);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的不是第一个节点</span></span><br><span class="line">    Node&lt;E&gt; parent = root;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">// 1.找到父节点</span></span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cmp = compare(element, node.element);</span><br><span class="line">        <span class="comment">// 保存一下父节点</span></span><br><span class="line">        parent = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 重复的数据进行覆盖</span></span><br><span class="line">            node.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.根据最后比较结果看是插入左子节点还是右子节点</span></span><br><span class="line">    Node&lt;E&gt; addNode = <span class="keyword">new</span> Node&lt;&gt;(element, parent);</span><br><span class="line">    <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = addNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>几个网站：<br><a href="http://btv.melezinek.cz/binary-search-tree.html" target="_blank" rel="noopener">http://btv.melezinek.cz/binary-search-tree.html</a></p>
<h5><span id="1-二叉树遍历">1、二叉树遍历</span></h5><ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<p>线性数据结构的遍历是根据下标访问顺序的不同产生<code>正序遍历</code>和<code>逆序遍历</code>。</p>
<p>二叉树的遍历是根据节点访问顺序的不同，没有索引的概念。</p>
<h6><span id="1-前序遍历">1、前序遍历</span></h6><p>根节点，左子树，右子树。</p>
<img src="/images/数据结构/image-20201126165558039.png" alt="image-20201126165558039" style="zoom:50%;">

<ul>
<li><p>递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preorderTraversal(root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    System.out.println(node.element);</span><br><span class="line">    <span class="comment">// 前序遍历左子树</span></span><br><span class="line">    preorderTraversal(node.left);</span><br><span class="line">    <span class="comment">// 前序遍历右子树</span></span><br><span class="line">    preorderTraversal(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        result.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将右子节点入栈，再将左子节点入栈，保证出栈时的先后顺序是根、左、右</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6><span id="2-中序遍历">2、中序遍历</span></h6><p>根节点，左子树，右子树。（根节点，右子树，左子树）。</p>
<img src="/images/数据结构/image-20201126171610410.png" alt="image-20201126171610410" style="zoom:50%;">

<ul>
<li><p>递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inorderTraversal(root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历左子树</span></span><br><span class="line">    inorderTraversal(node.left);</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    System.out.println(node.element);</span><br><span class="line">    <span class="comment">// 中序遍历右子树</span></span><br><span class="line">    inorderTraversal(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortStack</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  TreeNode tempNode = node;</span><br><span class="line">  Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(tempNode != <span class="keyword">null</span> || stack.isEmpty == <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tempNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 入栈</span></span><br><span class="line">      stack.push(tempNode);</span><br><span class="line">      <span class="comment">// 继续向下检测左子树</span></span><br><span class="line">      tempNode = tempNode.left;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      tempNode = stack.pop();</span><br><span class="line">      System.out.print(tempNode.val);</span><br><span class="line">      tempNode = tempNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6><span id="3-后序遍历">3、后序遍历</span></h6><p>左子树，右子树，根节点，适用一些先子后父的操作。</p>
<img src="/images/数据结构/image-20201126174517611.png" alt="image-20201126174517611" style="zoom:50%;">

<ul>
<li><p>递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postorderTraversal(root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrderTraversal</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历左子树</span></span><br><span class="line">    postorderTraversal(node.left);</span><br><span class="line">    <span class="comment">// 后序遍历右子树</span></span><br><span class="line">    postorderTraversal(node.right);</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    System.out.println(node.element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我们先遍历左孩子，再遍历右孩子。得到头-右-左。</span></span><br><span class="line"><span class="comment">// 我们将它逆序就是左-右-头，这就是一个后序遍历。</span></span><br><span class="line"><span class="comment">// 因为逆序的话，我们就需要两个栈才能完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack1.push(root); <span class="comment">// 先将头节点压栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty()) &#123; <span class="comment">// 栈里面有数据就循环</span></span><br><span class="line">        TreeNode node = stack1.pop();<span class="comment">// 弹出栈里面的数据</span></span><br><span class="line">        stack2.push(node); <span class="comment">// 放到备用栈，用来逆序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">        result.add(stack2.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6><span id="4-层序遍历">4、层序遍历</span></h6><p>从上到下，从左到右依次访问每一个节点。适用于计算二叉树的高度，判断一棵树是否为完全二叉树。</p>
<img src="/images/数据结构/image-20201126175549541.png" alt="image-20201126175549541" style="zoom:50%;">

<p>实现思路：利用<strong>队列先进先出</strong>的原则：</p>
<ul>
<li>1、根节点入队；</li>
<li>2、循环执行以下操作，直到队列为空<ul>
<li>1）将队头节点A出队，进行访问；</li>
<li>2）将A的左子节点入队；</li>
<li>3）将A的右子节点入队；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.根节点入队</span></span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty) &#123;</span><br><span class="line">        <span class="comment">// 1.队头出队</span></span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        System.out.println(node.element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.右子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6><span id="5-接口设计">5、接口设计</span></h6><p>上面的遍历的操作都是写死的，执行打印操作，一般情况来说，遍历的操作都是执行开发者自定义的操作，并且还需要能够中途停止，比如遍历到某个节点的时候不需要再执行后面的遍历操作了，直接停止，像这种情况就需要在上面的遍历方法中传入一段待执行的代码，并且返回一个BOOL值，以停止遍历操作。</p>
<p>主要就是注意两点：</p>
<ul>
<li>自定义访问操作；</li>
<li>终止遍历</li>
</ul>
<p>1、<strong>递归方式</strong>：方法中都是临时变量，必须有一个不变的变量来控制是否终止，每次递归调用，只有visitor是唯一不变的，所以在visitor中保存是否终止操作的标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(Visitor&lt;E&gt; visitor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorderTraversal(root, visitor)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span> || visitor.stop) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历左子树</span></span><br><span class="line">    postorderTraversal(node.left, visitor);</span><br><span class="line">    <span class="comment">// 后序遍历右子树</span></span><br><span class="line">    postorderTraversal(node.right, visitor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止访问</span></span><br><span class="line">    <span class="keyword">if</span> (visitor.stop) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存标识</span></span><br><span class="line">    visitor.stop = visitor.visit(node.element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<strong>循环方式</strong>：直接在while循环中return就好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(Visitor&lt;E&gt; visitor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || visitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.根节点入队</span></span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 1.队头出队</span></span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        bool stop = visitor.visit(node.element);</span><br><span class="line">        <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.右子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="2-avl树">2、AVL树</span></h5><p>又称平衡二叉树。防止二叉搜索树退化成链表，使得查询时间复杂度变成O(n)，所以提出平衡二叉树，通过平衡保证整棵树的高度平衡。</p>
<ul>
<li><p>左子树和右子树的高度之差的绝对值小于等于1；</p>
</li>
<li><p>左子树和右子树也是平衡二叉树；</p>
</li>
<li><p>平衡因子只能是 -1、0、1；</p>
</li>
<li><p>高度 log(n)，n为节点个数。</p>
</li>
</ul>
<p>平衡因子 = 结点左子树的高度 - 结点右子树的高度。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9dd2eab0c7f04a2fbd74949ae6e24b3b.png" alt="9dd2eab0c7f04a2fbd74949ae6e24b3b"></p>
<h5><span id="3-红黑树">3、红黑树</span></h5><p>也是一种自平衡的二叉搜索树。（根到叶子最长路径不多于最短路径的2倍）,高度 log(n)</p>
<ul>
<li><p>节点必须是RED或者BLACK；</p>
</li>
<li><p>根节点必须是BLACK；</p>
</li>
<li><p>叶子节点都是BLACK；</p>
</li>
<li><p>RED节点的子节点都是BLACK；</p>
</li>
<li><p>从任一节点到叶子节点的所有路径都包含相同数目的BLACK节点。</p>
</li>
</ul>
<p>插入和删除主要有两个操作：变色+旋转。</p>
<p><strong>AVL树 VS 红黑树</strong>：</p>
<ul>
<li>红黑树只要<code>部分平衡</code>即可，降低对旋转的要求，保证每次插入最多需要3次旋转就能达到平衡；</li>
<li>AVL树要<code>绝对平衡</code>，插入新节点后需要旋转的次数不能确定；</li>
<li>红黑树（Olog(2n)）在搜索上比AVL树（Olog(n)）效率低，但在增删上高；</li>
</ul>
<h3><span id="三-b树">三、B树</span></h3><p>一种平衡的多路搜索树，不是二叉树，多用于文件系统，数据库的实现。复杂度O(log n)</p>
<ul>
<li><p>一个节点可以存超过2个元素，可以拥有超过2个子节点；</p>
</li>
<li><p>每个节点所有子树高度一致；</p>
</li>
</ul>
<img src="/images/数据结构/webp-20230516144029974.png" alt="webp-20230516144029974" style="zoom:25%;">



<h3><span id="四-trie树">四、Trie树</span></h3><p>也称字典树或前缀树，用于字符串匹配和词频统计等应用。</p>
<ul>
<li><p>搜索效率主要跟字符串的长度有关；</p>
</li>
<li><p>需要耗费大量的内存，因为一个字符对应一个节点；</p>
</li>
</ul>
<p>cat，dog，doggy，does，cast，add。</p>
<img src="/images/数据结构/600b0f13-9051-4410-94eb-a9cb830517f2.jpg" alt="600b0f13-9051-4410-94eb-a9cb830517f2" style="zoom: 50%;">



<h3><span id="五-哈夫曼树">五、哈夫曼树</span></h3><p>特殊的二叉树，它也被称为最优二叉树或霍夫曼树，常用于数据压缩算法中。</p>
<p>两个最小节点作为作为左右子树，两个节点的和作为根节点，形成一个新的树加入森林，一次往复最后形成一棵哈夫曼树。</p>
<p><strong>哈夫曼编码</strong>：</p>
<ul>
<li><p>现代压缩算法的基础</p>
</li>
<li><p>假设要把字符串[ABBBCCCCDDDDDDEEEE]转换成二进制编码传输：</p>
<ol>
<li>转成ASCII编码，有点冗长；</li>
<li>约定字母对应的二进制位，如A：000, B：001,。。。一共20个字母，60个二进制位。</li>
<li>哈夫曼编码，可以压缩至41个二进制位。</li>
</ol>
</li>
</ul>
<img src="/images/数据结构/c057f73c-254f-4a34-ba1e-b8a78f1bbcce.jpg" alt="c057f73c-254f-4a34-ba1e-b8a78f1bbcce" style="zoom: 50%;">



<h3><span id="六-集合treeset">六、集合(TreeSet)</span></h3><ul>
<li><p>基于红黑树（ Olog(n)级别 ）；</p>
</li>
<li><p>有序集合；</p>
</li>
<li><p>添加的对象必须实现Comparable接口，就是对象必须是可比较的。</p>
</li>
</ul>
<h3><span id="七-映射treemap">七、映射(TreeMap)</span></h3><ul>
<li>基于红黑树（ Olog(n)级别 ）；</li>
<li>key有序，可以实现有序遍历；</li>
<li>key必须具备可比较性（key就是一个set）</li>
<li>元素的分布是有序的</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/" rel="next" title="线性结构">
                <i class="fa fa-chevron-left"></i> 线性结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7+%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/" rel="prev" title="线性+树形结构">
                线性+树形结构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sivan</p>
              <p class="site-description motion-element" itemprop="description">随遇而安</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">1.</span> <span class="nav-text">一、基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.1.</span> <span class="nav-text">1、节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.2.</span> <span class="nav-text">2、子树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.3.</span> <span class="nav-text">3、节点的度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.4.</span> <span class="nav-text">4、树的度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.5.</span> <span class="nav-text">6、层数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.6.</span> <span class="nav-text">6、节点的深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.7.</span> <span class="nav-text">8、节点的高度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.8.</span> <span class="nav-text">8、树的高度和深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.9.</span> <span class="nav-text">9、直径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.0.10.</span> <span class="nav-text">10、有序树、无序树、森林</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">2.</span> <span class="nav-text">二、二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">2.1.</span> <span class="nav-text">1、真二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">2.2.</span> <span class="nav-text">2、满二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">2.3.</span> <span class="nav-text">3、完全二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">2.4.</span> <span class="nav-text">4、二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">2.4.1.</span> <span class="nav-text">1、二叉树遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">1、前序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">2、中序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">3、后序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">4、层序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">5、接口设计</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">2.4.2.</span> <span class="nav-text">2、AVL树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">2.4.3.</span> <span class="nav-text">3、红黑树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">3.</span> <span class="nav-text">三、B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">4.</span> <span class="nav-text">四、Trie树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">5.</span> <span class="nav-text">五、哈夫曼树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">6.</span> <span class="nav-text">六、集合(TreeSet)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">7.</span> <span class="nav-text">七、映射(TreeMap)</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sivan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
